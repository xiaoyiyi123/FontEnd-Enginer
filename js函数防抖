函数防抖(debounce)
在一定时间内，在动作被连续频繁出发的情况下，动作只会执行一次，
即调用动作过n秒之后，才会执行该动作
 <input type="text"/>
    <script>
     /*防抖函数
    *一个时间在一定时间内被多次触发，只执行最后一次
    *实现思路：将回调函数放到一个setTimeout函数中,但是由于js的setTimeout的运行机制，
    *在设置的delay时间内如果多次触发的话，计算姐的时间将会被在此基础上再次设置从而就会被触发多次
    *所以我们设置一个clearTimeout阻止setTimeout里的方法执行，
    *目的是将事件内部的连续动作删掉
    *待到用户不触发这事件了，那么setTimeout就执行这个方法
    */
   function sucess(e){
       console.log(e.target.value);
   }
   function debounce(fn,delay){
        var timer;
        return function(e){
            clearTimeout(timer);
            //console.log(e.target.value);
            timer = setTimeout(function(){
                fn.apply(this,[e]);
            },delay);
        };
   }
   var oDebounce = debounce(sucess,2000);
   var input = document.querySelector("input");
   input.addEventListener("input",oDebounce);
    </script>

从头捋一下函数防抖的实现过程
我本原本给一个按钮绑定一个点击事件
<button in = 'btn'>submit success</button>
function sucess(){
  console.log("submit sucess");
}
var btn = document.getElementById('btn');
btn.addEventListener('click',sucess);
但是有一个问题，就是不停点击的话会不停地触发事件，为了防止这种情况考虑如何来防抖，即不论用户怎么点击在限定时间内只执行一次
实现过程
<button in = 'btn'>submit success</button>
function sucess(){
  console.log("submit sucess");
}
const debounce(fn,delay) =>{
  let timer = null;
  return()={//将修饰的success函数用return给返回出去
    clearTime(timer);//用户每次输入的时候把前一个setTimeout给clear掉
    timer = setTimeout(()=>{
    fn.apply(this,arguments);//将this绑定到func函数内不被更改因为不绑定的话，setTimeout里面的this指向的是全局
    },delay);
  } 
}
const oDebounce = debounce(sucess,1000);
let btn = document.getElementById('btn');
btn.addEventListener('click',oDebounce);











