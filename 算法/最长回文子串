给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"


解体思路：
利用动态规划的思路解题

首先我们需要明白一点就是，如果一个字符串是回文字符串，那么去掉这个字符串的首和尾两个字符，剩下的子串依然是回文字符串，
所以一个判断一个字符串是不是回文字符串，要看他的里面的去掉首尾两个字符，剩下的字符是否是回文字符串。
然后如果一个字符串的首尾两个字符不相同，那么它一定不是一个回文字符串。

然后动态规划最重要的就是状态转移方程，如何定义动态转移方程。
首先明确dp数组的含义，这里我们定义dp数组用来表示当前字符串是否是回文字符串，所以dp数组里面只存的是一个一个的布尔类型的值，表示的意义是当前字符串是否是回文字符串。
所以我们这里的状态转移方程就是
if(s[i] === s[j] && dp[i+1][j-1]){//意思是如果当前字符串的首和尾两个字符相等，并且去掉首和尾两个字符，里面的子串让然是回文字符串
                                  //那么当前字符串是回文字符串
  dp[i][j] = true
}
特殊情况，当i === j的情况下，表示字符串只有一个字符，所以一定是回文字符串
此时
if(i === j){
  dp[i][j] = true
}
特殊情况2， 当i和j相邻的情况下，并且相邻的字符串相等，表示当前字符串只有两个字符并且这两个字符相等，则是回文字符串
if(j-i ===1 && s[j] === s[i]){
  dp[i][j] = true
}


/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if(!s || s.length === 0){
        return s;
    }
    var res = s[0];
    var dp = Array.from(new Array(s.length),() => new Array(s.length));
    for(var i = s.length-1; i>=0; i--){//循环从字符串最后一位开始
        for(var j = i; j < s.length; j++){//j在i的基础上加一循环比较
            if(i===j){
                dp[i][j] = true;
            }else if(j-i === 1 && s[i] === s[j]){
                dp[i][j] = true;
            }else if(s[i] === s[j] && dp[i+1][j-1]){
                dp[i][j] = true;
            }else{
                dp[i][j] = false;
            }

            if(dp[i][j] && j-i+1 > res.length){//当dp[i][j] == true是回文字符串的时候，判断一下，这个回文字符串的长度和上一次的长度，如果比他长则更新
                res = s.slice(i,j+1)//更新res
            }
        }
    }
    return res;//并将res返回
};



总结：就是判断这个字符串是不是回文字符串，如果是，再比较他的长度和刚刚的长度，如果长度更大则重新截取并返回
