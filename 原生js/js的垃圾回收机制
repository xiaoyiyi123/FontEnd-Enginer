1.了解js的垃圾回收机制吗？
Js具有自动垃圾回收机制。垃圾收集器会找出那些不再继续使用的变量，然后释放其内存，为此，垃圾收集器会按照固定的时间间隔（或者代码中预定的收集时间）,周期性的执行这一操作。garbage collection, 简称GC

标记清除
工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
工作流程：
1.    垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
2.    去掉环境中的变量以及被环境中的变量引用的变量的标记。
3.    再被加上标记的会被视为准备删除的变量。
4.    垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。
引用计数 方式
工作原理：跟踪记录每个值被引用的次数。
工作流程：
1.    声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
2.    同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.
3.    当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.
4.    当引用次数变成0时，说明没办法访问这个值了。
5.    当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。
但是循环引用的时候就会释放不掉内存。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。
因为IE中的BOM、DOM的实现使用了COM，而COM对象使用的垃圾收集机制是引用计数策略。所以会存在循环引用的问题。
解决：手工断开js对象和DOM之间的链接。赋值为null。IE9把DOM和BOM转换成真正的JS对象了，所以避免了这个问题。
什么情况会引起内存泄漏？

内存泄漏。
1.    意外的全局变量引起的内存泄漏。
原因：全局变量，不会被回收。
解决：使用严格模式避免。
2.    闭包引起的内存泄漏
原因：闭包可以维持函数内局部变量，使其得不到释放。
解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。
3.    没有清理的DOM元素引用
原因：虽然别的地方删除了，但是对象中还存在对dom的引用
解决：手动删除。
4.    被遗忘的定时器或者回调
原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。
解决：手动删除定时器和dom。
5.    子元素存在引用引起的内存泄漏
原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。
解决：手动删除清空。





