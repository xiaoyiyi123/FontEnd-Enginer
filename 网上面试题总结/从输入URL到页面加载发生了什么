DNS解析
TCP连接
发送http请求
服务器处理请求并返回HTTP报文
浏览器解析渲染页面
连接结束

1.DNS解析：
DNS domain name of system域名系统，是互联网中域名和IP地址的相互映射的分布式数据库
DNS解析实际上是寻找哪台机器上有用户需要的资源的过程。IP地址是互联网中唯一表示一台电脑的标示，
但是不方便用户来使用，所以网址是为了方便用户的去查找互联网中的其他计算机。
DNS解析实际上就是实现了网址到IP地址的转换。
首先在本地域名服务器中查询IP地址，如果没有找到的情况下，
本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，
本地域名会向com顶级域名服务器发送一个请求，依次类推下去。
直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。
客户端-->本地域名服务器-->根域名服务器-->com服务器-->google.com服务器一层层往上找，直到找到为止。

2。TCP连接 https://www.cnblogs.com/linuxk/p/9276803.html
三次握手过程说明： 
1、由客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，
并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）
2、由服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，
并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，
以便客户端收到信息时，知晓自己的TCP建立请求已得到验证
（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接。
3、客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，
在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）

四次挥手过程说明： 
1、客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，
并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）
2、服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，
而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，
以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）
3、服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，
所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。
（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）
4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，
ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。
（FIN=1，ACK=z+1，seq=h，h为客户端随机生成） 
至此TCP断开的4次挥手过程完毕

HTTP请求：
发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口
(HTTP协议80/8080, HTTPS协议443)。
HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。
请求行
格式如下:
Method Request-URL HTTP-Version CRLF
eg: GET index.html HTTP/1.1
常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。
请求报头
请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。
PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。
常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, 
Content-Type, Authorization, Cookie, User-Agent等。
Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。
Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，
这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。
请求正文
当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。
在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。
这时就需要设置Content-Type: application/json。

服务器处理请求并返回HTTP报文
自然而然这部分对应的就是后端工程师眼中的HTTP。
后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。
它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。
这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。
HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。

状态码
状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:
1xx：指示信息–表示请求已接收，继续处理。
2xx：成功–表示请求已被成功接收、理解、接受。
3xx：重定向–要完成请求必须进行更进一步的操作。
4xx：客户端错误–请求有语法错误或请求无法实现。
5xx：服务器端错误–服务器未能实现合法的请求。
平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。
200:ok：成功，
201：CREATED：一般应用于告诉服务器创建一个新文件夹，最后服务器创建成功后返回的状态码
204: NO CONTENT：对于某些请求（例如：PUT或者DELETE），服务器不想处理，可以返回空内容，并且用204状态码告知
301: Moved Permanetly：永久重定向（永久转移）
302: Moved Temporarily：临时转移
304: Not Modified：设置HTTP的协商缓存
400: Bad Request：传递给服务器的参数错误
401: Unauthorized：无权限访问
404: Not Found：请求地址错误
500: Internal Server Error：未知名服务器错误
503: Service Unavailable： 服务器超负荷


5.浏览器解析渲染页面https://juejin.im/post/5a8e242c5188257a6b060000
浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？
浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，
等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，
涉及到两个概念: reflow(回流)和repain(重绘)。
DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;
当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。
页面在首次加载时必然会经历reflow和repain。
reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。
所以我们应该尽可能少的减少reflow和repain。

所以浏览器的渲染过程主要包括以下几步：
解析HTML生成DOM树。
解析CSS生成CSSOM规则树。
将DOM树与CSSOM规则树合并在一起生成渲染树。
遍历渲染树开始布局，计算每个节点的位置大小信息。
将渲染树每个节点绘制到屏幕。


































