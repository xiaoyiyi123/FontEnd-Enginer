函数节流：本质就是 让时间一定在超过规定的时间执行一次
比如规定的时间2秒触发一次事件，一定是每隔两秒触发一次事件
定时器加上开关的方法实现
function success(){
            console.log("success");
        }
function throttle(fn, delay){
   var flag = true;
   return function(){
         if(!flag) return;
         flag = false;
         setTimeout(function(){
         fn.apply(this);
         flag = true;//设置的delay的时间之后将flag设置为true
         },delay);
         } 
}

var oThrottle = throttle(success,2000);
var btn = document.getElementById("btn");
btn.addEventListener('click',oThrottle);


<div id='panel' style="background:red;width:200px;height:200px"></div>
 
function throttle(fn, threshhold) {
            var timeout
            var start = new Date;
            var threshhold = threshhold || 160
            return function () {

                var context = this, args = arguments, curr = new Date() - 0

                clearTimeout(timeout)//总是干掉事件回调
                if (curr - start >= threshhold) {
                    console.log("now", curr, curr - start)//注意这里相减的结果，都差不多是160左右
                    fn.apply(context, args) //只执行一部分方法，这些方法是在某个时间段内执行一次
                    start = curr
                } else {
                    //让方法在脱离事件后也能执行一次
                    timeout = setTimeout(function () {
                        fn.apply(context, args)
                    }, threshhold);
                }
            }
        }
        var mousemove = throttle(function (e) {
            console.log(e.pageX, e.pageY)
        });
        / 绑定监听
        document.querySelector("#panel").addEventListener('mousemove', mousemove);
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
