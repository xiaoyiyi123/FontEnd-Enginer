我们在二叉树中来搜索p和q，然后从路径中找到最后一个相同的节点即为父节点，
我们可以用递归来实现，在递归函数中，我们首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。
if(root == null || p == root || q == root) return root;

否则的话就对其左右子结点分别调用递归函数，
TreeNode left = lowestCommonAncestor(root.left, p, q);
TreeNode right = lowestCommonAncestor(root.right, p, q);
    
由于这道题限制了p和q一定都在二叉树中存在，
那么如果当前结点不等于p或q，
p和q要么分别位于左右子树中，
要么同时位于左子树，或者同时位于右子树：

1）若p和q要么分别位于左右子树中，
那么对左右子结点调用递归函数，会分别返回p和q结点的位置，
而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。
 if(left != null && right != null) return root; //情况1

2）若p和q同时位于左子树，这里有两种情况，一种情况是left会返回p和q中较高的那个位置，而right会返回空，所以我们最终返回非空的left即可，这就是题目中的例子2的情况。
还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。
return left != null ? left : right;//情况2，3

3）若p和q同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，
还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回。
return left != null ? left : right;//情况2，3


public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || p == root || q == root) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left != null && right != null) return root; //情况1
    return left != null ? left : right;//情况2，3
}

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || p == root || q == root){
            return root;
        }
        TreeNode leftNode = lowestCommonAncestor(root.left,p,q);//递归查找左子树
        TreeNode  rightNode = lowestCommonAncestor(root.right,p,q);//递归查找右子树

        if(leftNode != null && rightNode != null){
            return root;//说明p，q两个节点分别存在root节点的两颗子树中
        }
        if(leftNode == null && rightNode != null){//说明p，q同时存在于右子树中返回右子树查找的结果
            return rightNode;
        }else{
            return leftNode;
        }

    }
