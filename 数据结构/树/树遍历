//递归的方式实现
	//前序遍历
	public void preOrder(TreeNode root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.getLeftNode());
			preOrder(root.getRightNode());
		}
	}
	//中序遍历
	public void middleOrder(TreeNode root) {
		if(root != null) {
			middleOrder(root.getLeftNode());
			System.out.println(root.data);
			middleOrder(root.getRightNode());
		}
	}
	
	//后序遍历
	public void lastOrder(TreeNode root) {
		if(root != null) {
			lastOrder(root.getLeftNode());//每次获取root.getLeftNode()相当于获取当前节点的左子节点，然后把左子节点当作下一次寻找的节点实现递归
			lastOrder(root.getRightNode());
			System.out.println(root.data);
		}
	}



//层次遍历
	/**
	 * 实现思路
	 * 借用队列这一数据结构先进先出
	 * 将给定的当前节点添加到队列中，然后将它从队列中取出，赋值给一个中间变量temp
	 * 判断这个中间变量是否有左子节点和右子节点，将他的左右子节点按顺序添加到队列当中
	 * 然后把当前队列中的位于第一个的值取出，接着赋值给中间变量，再找中间变量的左右子节点，添加到队列中
	 * 以此循环当当前队列为空时结束循环
	 * */
	public void levelOrder(TreeNode root) {
		LinkedList<TreeNode> queue = new LinkedList<>(); 
		queue.offer(root);
		while(!queue.isEmpty()) {
			TreeNode temp = queue.poll();//定义一个中间变量，每次这个中间变量的值，都等于从队列中出的那个节点
			if(temp.getLeftNode() != null) {
				queue.offer(temp.getLeftNode());
			}
			if(temp.getRightNode() != null) {
				queue.offer(temp.getRightNode());
			}
		}
	}
