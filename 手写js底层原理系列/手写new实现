// new运算的过程
/**
 * 1、创建一个空对象；
 * 2、该空对象的原型指向构造函数（链接原型）：将构造函数的 prototype 赋值给对象的 __proto__属性；
 * 3、绑定 this：将对象作为构造函数的 this 传进去，并执行该构造函数；
 * 4、返回新对象：如果构造函数返回的是一个对象，则返回该对象；否则（若没有返回值或者返回基本类型），返回第一步中新创建的对象；
 */
var Person = function(name) {
    this.name = name
    console.log('name is ', this.name)
}
Person.prototype.getName = function() {
    return this.name
}
var objectFactory = function() {
    // 1、创建一个空对象
    var obj = new Object()
    console.log('before shift arguments = ',arguments)
    获取构造函数
    Constructor = [].shift.call(arguments)
    console.log('after shift arguments = ', arguments)
    console.log(`Constructor = ${Constructor}`)
    // 2、该空对象的原型指向构造函数： 将构造函数的prototype 赋值给空对象的 __proto__属性；
    obj.__proto__ = Constructor.prototype
    // 3、将空对象作为构造函数的this传进去，并执行该构造函数
    var ret = Constructor.apply(obj, arguments)
    // 4、返回新对象：如果构造函数返回的是一个对象，则返回该对象；否则（若没有返回值或者返回基本类型），返回第一步中新创建的对象；
    return typeof ret == 'object' ? ret : obj
}
var a = objectFactory(Person, 'yandong')
console.log('执行后的name = ', a.name)

Constructor = [].shift.call(arguments)
意思就是：arguments对象调用数组的shift()方法。
而shift()方法会删除并返回数组的第一个元素
当我们执行objectFactory(Person, 'anne')的时候
跳转到objectFactory函数内部，arguments这个类数组会全部接收Person参数以及‘anne’参数

所以Constructor = [].shift.call(arguments)这句代码删除并且返回的就是传入call方法或者apply方法的第一个对象参数，也就是Person。
执行了shift之后，arguments就只剩下执行函数所需的参数列表或者参数数组了
















