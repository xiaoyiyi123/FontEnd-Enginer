原本call的方法使用：
 var name = "wang";
 var age = 13;
 var obj = {
    name: "liu",
    age: 18
   };
 function sayHi() {
     console.log(this.name);
   }
 sayHi();//wang
 sayHi.call(obj);//liu
 
 手写实现call方法
 Function,prototype.myCall = function(context){
 
  if(typeof this !== "function"){
    console.error("type error");
  }
  context = context || window;//call函数第一个参数为this指向目标，若不传指向window
  context.fn = this;//将要执行的函数赋值context对象的fn属性，这样调用函数时，内部this就指向了context
  const args = [...arguments].slice(1);//获取参数
  const result = context.fn(...args);//原本call函数调用原函数，这里也调用函数
  delete context.fn;//删除context对象的fn属性
  return result;//调用结果返回
 }
 实现分析：
 1.context为可选参数，如果不传的话默认为window
 2.给context创建一个fn属性，并将值设置为需要的调用的函数 context.fn = this
 3.因为call可以传入多个参数，所以需要将参数剥离出来
 4.调用函数并将对象上的函数删除
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
