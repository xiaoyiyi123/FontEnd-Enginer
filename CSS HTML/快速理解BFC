BFC:block formatting context会计格式化上下文
W3C的官方解释：决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。
当涉及到可视化布局的时候BFC提供了一个环境HTML元素在这个环境中按照一定规则进行布局。
BFC的目的就是：
形成一个完全独立的空间，让空间里的子元素不会影响到外面的布局

触发BFC
1.float不为none
2.position不为relative和static
3.overflow为auto scroll和hidden
4.display的值为table-cell/inline-block

BFC能解决的问题：
第一.解决浮动元素另附元素高度塌陷的问题
假设页面里有一个父元素和几个子元素，这几个子元素都设为浮动时，父元素高度会发生塌陷。
原因：浮动的子元素脱离了文档流，被提起来形成新的队列。
下方的普通队列的元素无法触及它。父元素检测不到它的存在无法被它撑开，就会发生父元素高度塌陷后面的布局也会垮掉。
解决方法：
1.触发BFC
给父元素添加属性{overflow:hidden;}
还可以添加属性{display:table-cell;}
{display:block;}
{display:fixed;}
{position:absolute}来触发BFC，出发了BFC的容器就是页面上一个完全隔离的容器。
容器里的子元素绝不会影响到外面的元素。
出发了BFC的父元素在计算高度时不得不让浮动的子元素也参与进来，变相的实现了清除内部浮动的目的。
2.让父元素也浮动起来
让父元素和子元素一起脱离文档流，使父元素自适应子元素的高度。
优点：代码量极少。 缺点：是一种将错就错的方法。会直接影响父元素之后的元素的排列从而引发其他问题。
3.让父元素添加一个固定高度
但这个方法只适用于已知子元素高度的情况。
4.在浮动的子元素后面增加一个空元素
设置{clear:both}来清除浮动
优点：简单易懂容易掌握
缺点：会增加无意义的标签，不利于以后维护。
5。为浮动的最后一个子元素设置伪元素
设置after{clear:both}用伪类替代了空元素
优点：结构和语义完全正确。缺点：复用不当会到值代码量增加。

第二：解决自适应布局的问题：
左侧定宽右侧主体随页面宽度自适应变化：通常是用浮动来实现的。
利用：1.块级元素会尽可能占满一行的特性。使得右边的元素可以随着页面宽度变化而变化。
2.浮动的特性；让左侧元素覆盖在右边元素的上方，同时还能挤开下方元素里面的内容，让页面看起来像是亮蓝
但随着右边元素里面文字增加超出左边元素的高度之后，文字就会流到最左侧。看起来就是文字环绕左侧元素。
因此为右侧元素触发BFC，触发了BFC的容器就是页面上的一个完全隔离开的容器，容器里的子元素绝对不会影响到外面的元素。
其他方法：
1.左边左浮动右边设着{margin-left:200px}
.left{
  float:left;
  width:200px;
}
.right{
  margin-left:200px;
}
2.左边绝对定位右边设置{margin-left:200px;}
.left{
  position:absolute;
  top:0;
  left:0;
  bottom:0;
  width:200px
}
.right{
  margin-left:200px;
}
3.右侧元素设置顶线和右线的位置为0左边的位置为200，宽度为100%
.left{
  position:absolute;
  top:0;
  left:0;
  bottom:0;
  width:200px;
}
.right{
  position:absoulte;
  top:0;
  right:0;
  left:200px;
  width:100%;
}

第三：解决外边觉垂直方向重合问题margin塌陷问题








