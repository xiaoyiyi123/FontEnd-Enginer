扫盲：
1.进程与线程
进程process就是打开的每个程序，每个程序可以同时做很多事情，这些同时做的事情叫做线程。
进程就是当前的应用，线程就是应用程序当中干活的




一.浏览器的运行机制

客户端向服务器端发送请求（DNS解析，TCP协议，HTTPs/HTTP）
服务器响应阶段（http状态码，304缓存，http报文）

浏览器在拿到服务器端返回的代码之后会在内存中开辟出一块占内存，用来给代码提供执行环境，分配一个主线程去一行一行的解析和执行代码。
当浏览器遇到link/script/img等请求后都会开辟全新的线程去加载资源文件。新开辟的空间叫做任务队列（task queue）去执行这些异步资源请求操作。
主线程继续去执行下面的操作。一直执行到最后。把html的dom结构渲染完毕------>DOM结构生成完毕

主线程去任务队列中拿出排在第一位的回调函数放到主线程当中的执行栈去执行，执行完毕后再去任务队列中去找，一直到执行完毕（也称事件循环，任务队列中还包括宏任务和微任务队列）
CSS处理完之后生成CSSOM

将DOM树和CSSOM结合到一起生成渲染树render Tree
递归的计算每个节点的精准位置，通知电脑的gpu开始绘制（这个过程之前会发生回流和重绘计算节点在页面中的位置，一定实现发生回流再经过重绘节点在页面中显示的像素大小）


前端性能优化
减少HTTP请求次数和大小
1.资源合并并压缩
2.图片的懒加载
3.音视频的走流文件
4.DNS缓存
5.304缓存
。。。

浏览器是如何运行的，如何渲染页面的？
1.构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（content Tree/ Dom Tree）
2.构建渲染树（construct）：解析对应的css样式文件信息（包括js生成的样式和外部css文件），构建渲染树，人render tree中的每个node都有自己的style
3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小，位置等，给出每个节点所应该在屏幕上出现的精准坐标；
4。绘制渲染树（paint/repaint）：遍历渲染树，使用UI层来绘制每个节点：



二.重绘和重排
重绘：一个元素外观发生改变所触发的浏览器行为，浏览器会根据元素的新属性来重新绘制，使元素呈现新的外观（但宽高。大小，位置等不变）
触发重绘的条件是改变元素的外观
重排（回流，重构）：元素的大小或者位置发生了变化
当渲染树的一部分因为元素的规模尺寸，布局隐藏等改变而需要重新构建的时候，称做重构。
每个页面至少需要一次回流，就是在页面第一次加载的时候。
触发重拍的条件：任何页面布局和几何属性的改变都会 触发重排（其中页面的初始化触发的重排不可避免）

优化：
1.浏览器自己的优化：浏览器会维护一个队列，把所有会引起回流重拍的操作放入这个队列，等队列中的操作到达一定数量或者到了一定的时间间隔，浏览器就会福禄寿队列，进行一个批次初六，这样会让多次回流变成一次回流。
2.我们自己平时需要注意到的优化：
要减少重排和重绘即要减少对渲染树的操作，可以合并多次的DOM和样式的改变，减少对style样式的请求。
（1）。直接改变元素的className
（2）。display先设置为none，然后进行页面布局等操作，设置当布局操作完成后将元素设置为block，这样就只会两次重绘和重排
（3）。如果需要创建多个dom节点，可以使用DocumentFragment 船舰完后一次性的加入document.


前端性能优化之：避免DOM的回流
放弃传统的操作dom的时代，基于vue/react开始数据影响视图模式
mvvm/mvc/virtual dom/dom diff

分离读写操作（现代的浏览器都有渲染队列的机制）
当代浏览器会维护一个队列，把所有会引起回流重拍的操作放入这个队列，等队列中的操作到达一定数量或者到了一定的时间间隔，浏览器就会福禄寿队列，
进行一个批次处理，这样会让多次回流变成一次回流。当时如果在连续的回流操作中间插一条读取操作就会，中断连续的批次操作处理。
所以我们推崇将写操作和读取操作分离开来，都改完样式之后，在后面读取操作。

样式集中改变，批量操作。
可以写一个样式类比如.aa{
                    width:200px;
                    height:200px;
                    background-corlor:red;
                    }
                    box.className = "aa" 进行批量处理
 
缓存处理：
let width = box.clientWidth;
let height = box.clientHeight;
boxWidth = width +　'10' + 'px';
boxheight = height +　'10' + 'px';

文档碎批量处理
let frg = document.createDocumentFrament();
for(let i = 0; i < 5; i++){
  let newLi = document.createElement('li');
  newLi.innerHTML = i;
  frg.appendChild(newLi);
}
//一次性把内容放到容器中，引发一次回流
box.appendChild(frg);
//但是现在这种方式我们不常用了，因为我们有了模版字符串

let str = '';
for(let i = 0; i < 5; i++){
  str += `<li>${i}</li>`
}
box.innerHTML = str;

动画效果应用到position: absolute/fixed(脱离文档流，减少回流)
CSS3硬件加速（GPU加速）
transform\opacity\filters 这些属性会触发硬件加速，不会触发回流和重绘
可能会有的坑：过多的使用会占用大量内存，性能消耗严重，有时候会导致字体模糊

避免table布局和食用css的js表达式
































                    





























